# Two dimensional Gaussian Distribution
create2DGaussian <- function(mean = mean, sigma = sigma, cov = cov, n) {
    # mean: 1D Array of length n
    # Mean of the n dimensional distribution
    
    # sigma: Variance to create the covariance matrix of the distribution
    # cov: Covariance of the distribution
    
    # REFERENCE: https://en.wikipedia.org/wiki/Multivariate_normal_distribution
    # Synthetice data is generated by gampling from 2 dimensional gaussian 
    # distribution.
    library(MASS)
    
    cov_mat <- matrix(c(sigma, cov, cov, sigma ), nrow = 2)
    x <- mvrnorm(n, mu = c(mean, mean), Sigma = cov_mat)
    plot(x, xlab = "Simulated x1 values", ylab = "Simulated x2 values", 
         main = "2D Gaussian Distribution")
    return(x)
}

# Interpretting Principle Component Analysis
getCorrelatedZeroMeanData <- function(data = data) {
    # data: An n dimensional matrix for which correlated zero mean to be calculated
    
    # Center out the data by calculating the zero mean dataset. 
    
    col_means <- colMeans(data)
    return(data - col_means)
}

getCorrelatedCovariance <- function(corZeroMeanData) {
    # corZeroMeanData: An n dimensional matrix where the data is centered out
    
    # REFERENCE: https://en.wikipedia.org/wiki/Covariance
    
    cov_data <- cov(corZeroMeanData)
    return(cov_data)
}

# Eigen Decomposition
getTopPrincipalComponent <- function(data = data) {
    # data: An n dimensional matrix preferabled a centered out one for PCA calc
    
    # Eigen decomposition is performed to get eigen values and eigen vectors.
    # This function returns the top principle components (eigen vector) 
    # corresponding to top eigen values.
    
    # Step 1: Calculate Eigen Values and Eigen Vectors
    # Step 2: Find index of max eigen value
    # Step 3: Return the eigen vector corresponding to max eigen value
    
    egn <- eigen(data)
    return(egn$vectors[which.max(egn$values),])
}

getTopNPrincipalComponent <- function(data = data, n = 1) {
    egn <- eigen(data)
    sortedEgnVectors <- egn$vectors[order(-egn$values),]
    return(sortedEgnVectors[1:n,])
}

# PCA Scores
getPCAScores <- function(correlatedData, topComponent) {
    
    # PCA Scores are the compact representation of the given dataset. From the
    # top principal component a one dimensional representation for the original
    # data is calculated using dot product.
    
    return(correlatedData %*% topComponent)
}
set.seed(142)
dataCorr <- create2DGaussian(mean = 50, sigma = 1, cov = 0.9, n = 100)
corrZeroMeanData <- getCorrelatedZeroMeanData(dataCorr)
corrCovarianceData <- getCorrelatedCovariance(corrZeroMeanData)
topPrincipalComponent <- getTopPrincipalComponent(corrCovarianceData)
pcaScores <- getPCAScores(dataCorr, topPrincipalComponent)

print(topPrincipalComponent)

topNPrincipalComponent <- getTopNPrincipalComponent(corrCovarianceData, 3)
pcaScoresN <- getPCAScores(dataCorr, topNPrincipalComponent)

print(topNPrincipalComponent)







